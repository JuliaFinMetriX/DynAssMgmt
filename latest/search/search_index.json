{
    "docs": [
        {
            "location": "/", 
            "text": "DynAssMgmt.jl Documentation\n\n\nThis package implements a framework to set up and test dynamic asset management strategies.\n\n\n\n\nDynamic asset management types\n\n\n\n\n\n\nUtilities\n\n\n#\n\n\nDynAssMgmt.loadTestData\n \n \nMethod\n.\n\n\nloadTestData(dataName::String)\n\n\n\n\nLoad one of the predefined test data.\n\n\nfx / Fx:\n\n\nGarch\n dataset from \nEcdat R package\n.\n\n\nDaily observations of exchange rate data from 1980\u201301 to 1987\u201305\u201321. Following exchange rates are part of it:\n\n\n\n\ndm: exchange rate Dollar/Deutsch Mark\n\n\nbp: exchange rate of Dollar/British Pound\n\n\ncd: exchange rate of Dollar/Canadian Dollar\n\n\ndy: exchange rate of Dollar/Yen\n\n\nsf: exchange rate of Dollar/Swiss Franc\n\n\n\n\nsource\n\n\n\n\nIndex\n\n\n\n\nDynAssMgmt.DivFront\n\n\nDynAssMgmt.DivFrontSigmaTarget\n\n\nDynAssMgmt.EWMA\n\n\nDynAssMgmt.EffFront\n\n\nDynAssMgmt.GMVP\n\n\nDynAssMgmt.Invest\n\n\nDynAssMgmt.MaxSharpe\n\n\nDynAssMgmt.PF\n\n\nDynAssMgmt.RelativeTargetVola\n\n\nDynAssMgmt.ReturnType\n\n\nDynAssMgmt.Returns\n\n\nDynAssMgmt.SinglePeriodSpectrum\n\n\nDynAssMgmt.SinglePeriodTarget\n\n\nDynAssMgmt.TargetMu\n\n\nDynAssMgmt.TargetVola\n\n\nDynAssMgmt.Univ\n\n\nDynAssMgmt.UnivEstimator\n\n\nDynAssMgmt.UnivEvol\n\n\nDynAssMgmt.aggregateReturns\n\n\nDynAssMgmt.annualizeRiskReturn\n\n\nDynAssMgmt.apply\n\n\nDynAssMgmt.applyOverTime\n\n\nDynAssMgmt.computeReturns\n\n\nDynAssMgmt.getEwmaCov\n\n\nDynAssMgmt.getEwmaMean\n\n\nDynAssMgmt.getEwmaStd\n\n\nDynAssMgmt.getInPercentages\n\n\nDynAssMgmt.getMuInPercentages\n\n\nDynAssMgmt.getStdInPercentages\n\n\nDynAssMgmt.getUnivEvolFromMatlabFormat\n\n\nDynAssMgmt.getUnivExtrema\n\n\nDynAssMgmt.gmvp\n\n\nDynAssMgmt.gmvp_lev\n\n\nDynAssMgmt.loadTestData\n\n\nDynAssMgmt.locf\n\n\nDynAssMgmt.locf!\n\n\nDynAssMgmt.nocb\n\n\nDynAssMgmt.nocb!\n\n\nDynAssMgmt.normalizePrices\n\n\nDynAssMgmt.pfDivers\n\n\nDynAssMgmt.pfMoments\n\n\nDynAssMgmt.pfMu\n\n\nDynAssMgmt.pfVariance\n\n\nDynAssMgmt.rets2prices", 
            "title": "Introduction"
        }, 
        {
            "location": "/#dynassmgmtjl-documentation", 
            "text": "This package implements a framework to set up and test dynamic asset management strategies.", 
            "title": "DynAssMgmt.jl Documentation"
        }, 
        {
            "location": "/#dynamic-asset-management-types", 
            "text": "", 
            "title": "Dynamic asset management types"
        }, 
        {
            "location": "/#utilities", 
            "text": "#  DynAssMgmt.loadTestData     Method .  loadTestData(dataName::String)  Load one of the predefined test data.  fx / Fx:  Garch  dataset from  Ecdat R package .  Daily observations of exchange rate data from 1980\u201301 to 1987\u201305\u201321. Following exchange rates are part of it:   dm: exchange rate Dollar/Deutsch Mark  bp: exchange rate of Dollar/British Pound  cd: exchange rate of Dollar/Canadian Dollar  dy: exchange rate of Dollar/Yen  sf: exchange rate of Dollar/Swiss Franc   source", 
            "title": "Utilities"
        }, 
        {
            "location": "/#index", 
            "text": "DynAssMgmt.DivFront  DynAssMgmt.DivFrontSigmaTarget  DynAssMgmt.EWMA  DynAssMgmt.EffFront  DynAssMgmt.GMVP  DynAssMgmt.Invest  DynAssMgmt.MaxSharpe  DynAssMgmt.PF  DynAssMgmt.RelativeTargetVola  DynAssMgmt.ReturnType  DynAssMgmt.Returns  DynAssMgmt.SinglePeriodSpectrum  DynAssMgmt.SinglePeriodTarget  DynAssMgmt.TargetMu  DynAssMgmt.TargetVola  DynAssMgmt.Univ  DynAssMgmt.UnivEstimator  DynAssMgmt.UnivEvol  DynAssMgmt.aggregateReturns  DynAssMgmt.annualizeRiskReturn  DynAssMgmt.apply  DynAssMgmt.applyOverTime  DynAssMgmt.computeReturns  DynAssMgmt.getEwmaCov  DynAssMgmt.getEwmaMean  DynAssMgmt.getEwmaStd  DynAssMgmt.getInPercentages  DynAssMgmt.getMuInPercentages  DynAssMgmt.getStdInPercentages  DynAssMgmt.getUnivEvolFromMatlabFormat  DynAssMgmt.getUnivExtrema  DynAssMgmt.gmvp  DynAssMgmt.gmvp_lev  DynAssMgmt.loadTestData  DynAssMgmt.locf  DynAssMgmt.locf!  DynAssMgmt.nocb  DynAssMgmt.nocb!  DynAssMgmt.normalizePrices  DynAssMgmt.pfDivers  DynAssMgmt.pfMoments  DynAssMgmt.pfMu  DynAssMgmt.pfVariance  DynAssMgmt.rets2prices", 
            "title": "Index"
        }, 
        {
            "location": "/types/dataTypes/", 
            "text": "Return data should always come with additional meta-data to explicitly determine return properties. Therefore, the following data types exist. \n\n\n\n\nComposite types\n\n\n#\n\n\nDynAssMgmt.ReturnType\n \n \nType\n.\n\n\nReturnType(isPercent::Bool, isLog::Bool, period::Dates.DatePeriod, isGross::Bool)\n\n\n\n\nSpecification of return type. Returns could differ with regards to following properties:\n\n\n\n\nfractional / percentage returns\n\n\ndiscrete / logarithmic returns\n\n\ndaily, monthly, yearly, ... returns\n\n\nnet / gross returns\n\n\n\n\nStandard return type is \nfractional\n, \ndiscrete\n, \nnet\n daily returns.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.Returns\n \n \nType\n.\n\n\nReturns(data::TimeSeries.TimeArray, retType::ReturnType)\n\n\n\n\nData type to store return data together with meta-data.\n\n\nsource\n\n\n\n\nFields of composite types\n\n\njulia\n using DynAssMgmt\n\njulia\n fieldnames(ReturnType)\n4-element Array{Symbol,1}:\n :isPercent\n :isLog\n :period\n :isGross\n\njulia\n fieldnames(Returns)\n2-element Array{Symbol,1}:\n :data\n :retType\n\n\n\n\n\n\nPrice and return data handling\n\n\n#\n\n\nDynAssMgmt.normalizePrices\n \n \nFunction\n.\n\n\nnormalizePrices(xx::Array{Float64, 1})\n\n\n\n\nRescale prices such that first observation starts at 1.\n\n\nsource\n\n\nnormalizePrices(xx::Array{Float64, 2})\n\n\n\n\nsource\n\n\nnormalizePrices(xx::TimeArray)\n\n\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.computeReturns\n \n \nFunction\n.\n\n\ncomputeReturns(prices::Array{Float64, 1}, retType = ReturnType())\n\n\n\n\nCompute returns from prices. The function uses default settings for return calculations:\n\n\n\n\ndiscrete returns (not logarithmic)\n\n\nfractional returns (not percentage)\n\n\nsingle-period returns (not multi-period)\n\n\nnet returns (not gross returns)\n\n\nstraight-forward application to \nNaN\ns also\n\n\n\n\nsource\n\n\ncomputeReturns(prices::Array{Float64, 2}, retType = ReturnType())\n\n\n\n\nsource\n\n\ncomputeReturns(xx::TimeSeries.TimeArray, retType = ReturnType())\n\n\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.aggregateReturns\n \n \nFunction\n.\n\n\naggregateReturns(rets::Array{Float64, 1}, retType::ReturnType, prependStart=false)\n\n\n\n\nAggregate returns to performances (not prices). The function uses default types of returns:\n\n\n\n\ndiscrete returns (not logarithmic)\n\n\nfractional returns (not percentage)\n\n\nsingle-period returns (not multi-period)\n\n\nnet returns (not gross returns)\n\n\nconvention for how to deal with \nNaN\ns still needs to be defined\n\n\n\n\nsource\n\n\naggregateReturns(discRets::Array{Float64, 2}, retType::ReturnType, prependStart=false)\n\n\n\n\nsource\n\n\naggregateReturns(discRets::TimeSeries.TimeArray, retType::ReturnType, prependStart=false)\n\n\n\n\nsource\n\n\naggregateReturns(rets::Returns, prependStart=false)\n\n\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.rets2prices\n \n \nFunction\n.\n\n\nrets2prices(rets::Array{Float64, 1}, retType::ReturnType, startPrice=1., prependStart=false)\n\n\n\n\nAggregate returns to prices (not performances). The function uses default types of returns:\n\n\n\n\ndiscrete returns (not logarithmic)\n\n\nfractional returns (not percentage)\n\n\nsingle-period returns (not multi-period)\n\n\nnet returns (not gross returns)\n\n\nconvention for how to deal with \nNaN\ns still needs to be defined\n\n\n\n\nsource\n\n\nrets2prices(rets::Array{Float64, 2}, retType::ReturnType)\n\n\n\n\nsource\n\n\nrets2prices(rets::TimeSeries.TimeArray, retType::ReturnType, startPrice=1., prependStart=false)\n\n\n\n\nsource\n\n\nrets2prices(rets::Returns, startPrice=1., prependStart=false)\n\n\n\n\nsource\n\n\n\n\nData imputation\n\n\n#\n\n\nDynAssMgmt.locf!\n \n \nFunction\n.\n\n\nlocf!(xx::Array{Float64, 1})\n\n\n\n\nReplacing \nNaN\n according to \nlast observation carried forward\n.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.locf\n \n \nFunction\n.\n\n\nlocf(xx::Array{Float64, 1})\n\n\n\n\nReplacing \nNaN\n according to \nlast observation carried forward\n.\n\n\nsource\n\n\nlocf(xx::Array{Float64, 2})\n\n\n\n\nsource\n\n\nlocf(xx::TimeArray)\n\n\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.nocb!\n \n \nFunction\n.\n\n\nnocb!(xx::Array{Float64, 1})\n\n\n\n\nReplacing \nNaN\n according to \nnext observation carried backward\n.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.nocb\n \n \nFunction\n.\n\n\nnocb(xx::Array{Float64, 1})\n\n\n\n\nReplacing \nNaN\n according to \nnext observation carried backward\n.\n\n\nsource\n\n\nnocb(xx::Array{Float64, 2})\n\n\n\n\nsource\n\n\nnocb(xx::TimeArray)\n\n\n\n\nsource", 
            "title": "Return data"
        }, 
        {
            "location": "/types/dataTypes/#composite-types", 
            "text": "#  DynAssMgmt.ReturnType     Type .  ReturnType(isPercent::Bool, isLog::Bool, period::Dates.DatePeriod, isGross::Bool)  Specification of return type. Returns could differ with regards to following properties:   fractional / percentage returns  discrete / logarithmic returns  daily, monthly, yearly, ... returns  net / gross returns   Standard return type is  fractional ,  discrete ,  net  daily returns.  source  #  DynAssMgmt.Returns     Type .  Returns(data::TimeSeries.TimeArray, retType::ReturnType)  Data type to store return data together with meta-data.  source", 
            "title": "Composite types"
        }, 
        {
            "location": "/types/dataTypes/#fields-of-composite-types", 
            "text": "julia  using DynAssMgmt\n\njulia  fieldnames(ReturnType)\n4-element Array{Symbol,1}:\n :isPercent\n :isLog\n :period\n :isGross\n\njulia  fieldnames(Returns)\n2-element Array{Symbol,1}:\n :data\n :retType", 
            "title": "Fields of composite types"
        }, 
        {
            "location": "/types/dataTypes/#price-and-return-data-handling", 
            "text": "#  DynAssMgmt.normalizePrices     Function .  normalizePrices(xx::Array{Float64, 1})  Rescale prices such that first observation starts at 1.  source  normalizePrices(xx::Array{Float64, 2})  source  normalizePrices(xx::TimeArray)  source  #  DynAssMgmt.computeReturns     Function .  computeReturns(prices::Array{Float64, 1}, retType = ReturnType())  Compute returns from prices. The function uses default settings for return calculations:   discrete returns (not logarithmic)  fractional returns (not percentage)  single-period returns (not multi-period)  net returns (not gross returns)  straight-forward application to  NaN s also   source  computeReturns(prices::Array{Float64, 2}, retType = ReturnType())  source  computeReturns(xx::TimeSeries.TimeArray, retType = ReturnType())  source  #  DynAssMgmt.aggregateReturns     Function .  aggregateReturns(rets::Array{Float64, 1}, retType::ReturnType, prependStart=false)  Aggregate returns to performances (not prices). The function uses default types of returns:   discrete returns (not logarithmic)  fractional returns (not percentage)  single-period returns (not multi-period)  net returns (not gross returns)  convention for how to deal with  NaN s still needs to be defined   source  aggregateReturns(discRets::Array{Float64, 2}, retType::ReturnType, prependStart=false)  source  aggregateReturns(discRets::TimeSeries.TimeArray, retType::ReturnType, prependStart=false)  source  aggregateReturns(rets::Returns, prependStart=false)  source  #  DynAssMgmt.rets2prices     Function .  rets2prices(rets::Array{Float64, 1}, retType::ReturnType, startPrice=1., prependStart=false)  Aggregate returns to prices (not performances). The function uses default types of returns:   discrete returns (not logarithmic)  fractional returns (not percentage)  single-period returns (not multi-period)  net returns (not gross returns)  convention for how to deal with  NaN s still needs to be defined   source  rets2prices(rets::Array{Float64, 2}, retType::ReturnType)  source  rets2prices(rets::TimeSeries.TimeArray, retType::ReturnType, startPrice=1., prependStart=false)  source  rets2prices(rets::Returns, startPrice=1., prependStart=false)  source", 
            "title": "Price and return data handling"
        }, 
        {
            "location": "/types/dataTypes/#data-imputation", 
            "text": "#  DynAssMgmt.locf!     Function .  locf!(xx::Array{Float64, 1})  Replacing  NaN  according to  last observation carried forward .  source  #  DynAssMgmt.locf     Function .  locf(xx::Array{Float64, 1})  Replacing  NaN  according to  last observation carried forward .  source  locf(xx::Array{Float64, 2})  source  locf(xx::TimeArray)  source  #  DynAssMgmt.nocb!     Function .  nocb!(xx::Array{Float64, 1})  Replacing  NaN  according to  next observation carried backward .  source  #  DynAssMgmt.nocb     Function .  nocb(xx::Array{Float64, 1})  Replacing  NaN  according to  next observation carried backward .  source  nocb(xx::Array{Float64, 2})  source  nocb(xx::TimeArray)  source", 
            "title": "Data imputation"
        }, 
        {
            "location": "/types/estimatorTypes/", 
            "text": "Asset moments can be estimated according to a couple of ways.\n\n\n\n\nAbstract types\n\n\n#\n\n\nDynAssMgmt.UnivEstimator\n \n \nType\n.\n\n\nUnivEstimator\n\n\n\n\nAbstract super type for asset moment estimators.\n\n\nsource\n\n\n\n\nEstimators\n\n\n#\n\n\nDynAssMgmt.EWMA\n \n \nType\n.\n\n\nEWMA(muPersistence::Float64, covPersistence::Float64)\n\n\n\n\nExponential weighted moving average estimator of asset moments. \nmuPersistence\n is the lambda value of the estimator of mean asset returns, and \ncovPersistence\n is the lambda value for the covariance matrix.\n\n\nsource\n\n\n\n\nFields of composite types\n\n\njulia\n using DynAssMgmt\n\njulia\n fieldnames(EWMA)\n2-element Array{Symbol,1}:\n :muPersistence\n :covPersistence\n\n\n\n\n\n\nUsage\n\n\n#\n\n\nDynAssMgmt.apply\n \n \nMethod\n.\n\n\napply(thisEstimator::UnivEstimator, rets::Returns)\n\n\n\n\nApply some moment estimator to return data. In the background, \napply\n needs to be defined for each possible estimator.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.applyOverTime\n \n \nFunction\n.\n\n\napplyOverTime(thisEstimator::UnivEstimator, retsData::Returns, minObs::Int)\n\n\n\n\nSuccessively apply given moment estimator to return data. \nminObs\n determines the minimum number of observations. This bascially defines the first subsample where the estimator will be applied.\n\n\nsource\n\n\n\n\nFunctions\n\n\n#\n\n\nDynAssMgmt.getEwmaMean\n \n \nFunction\n.\n\n\ngetEwmaMean(data::Array{Float64, 1}, persistenceVal::Float64)\n\n\n\n\nEWMA estimator of expected value. \npersistenceVal\n defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation.\n\n\nsource\n\n\ngetEwmaMean(data::Array{Float64, 2}, persistenceVal::Float64)\n\n\n\n\nsource\n\n\ngetEwmaMean(data::TimeArray, persistenceVal::Float64)\n\n\n\n\nsource\n\n\ngetEwmaMean(data::Returns, persistenceVal::Float64)\n\n\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.getEwmaStd\n \n \nFunction\n.\n\n\ngetEwmaStd(data::Array{Float64, 1}, persistenceVal::Float64)\n\n\n\n\nEWMA estimator of standard deviation. \npersistenceVal\n defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation.\n\n\nsource\n\n\ngetEwmaStd(data::Array{Float64, 2}, persistenceVal::Float64)\n\n\n\n\nsource\n\n\ngetEwmaStd(data::TimeArray, persistenceVal::Float64)\n\n\n\n\nsource\n\n\ngetEwmaStd(data::Returns, persistenceVal::Float64)\n\n\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.getEwmaCov\n \n \nFunction\n.\n\n\ngetEwmaCov(data::Array{Float64, 1}, persistenceVal::Float64)\n\n\n\n\nEWMA estimator of covariance matrix. \npersistenceVal\n defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation.\n\n\nsource\n\n\ngetEwmaCov(data::TimeArray, persistenceVal::Float64)\n\n\n\n\nsource\n\n\ngetEwmaCov(data::Returns, persistenceVal::Float64)\n\n\n\n\nsource", 
            "title": "Moment estimators"
        }, 
        {
            "location": "/types/estimatorTypes/#abstract-types", 
            "text": "#  DynAssMgmt.UnivEstimator     Type .  UnivEstimator  Abstract super type for asset moment estimators.  source", 
            "title": "Abstract types"
        }, 
        {
            "location": "/types/estimatorTypes/#estimators", 
            "text": "#  DynAssMgmt.EWMA     Type .  EWMA(muPersistence::Float64, covPersistence::Float64)  Exponential weighted moving average estimator of asset moments.  muPersistence  is the lambda value of the estimator of mean asset returns, and  covPersistence  is the lambda value for the covariance matrix.  source", 
            "title": "Estimators"
        }, 
        {
            "location": "/types/estimatorTypes/#fields-of-composite-types", 
            "text": "julia  using DynAssMgmt\n\njulia  fieldnames(EWMA)\n2-element Array{Symbol,1}:\n :muPersistence\n :covPersistence", 
            "title": "Fields of composite types"
        }, 
        {
            "location": "/types/estimatorTypes/#usage", 
            "text": "#  DynAssMgmt.apply     Method .  apply(thisEstimator::UnivEstimator, rets::Returns)  Apply some moment estimator to return data. In the background,  apply  needs to be defined for each possible estimator.  source  #  DynAssMgmt.applyOverTime     Function .  applyOverTime(thisEstimator::UnivEstimator, retsData::Returns, minObs::Int)  Successively apply given moment estimator to return data.  minObs  determines the minimum number of observations. This bascially defines the first subsample where the estimator will be applied.  source", 
            "title": "Usage"
        }, 
        {
            "location": "/types/estimatorTypes/#functions", 
            "text": "#  DynAssMgmt.getEwmaMean     Function .  getEwmaMean(data::Array{Float64, 1}, persistenceVal::Float64)  EWMA estimator of expected value.  persistenceVal  defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation.  source  getEwmaMean(data::Array{Float64, 2}, persistenceVal::Float64)  source  getEwmaMean(data::TimeArray, persistenceVal::Float64)  source  getEwmaMean(data::Returns, persistenceVal::Float64)  source  #  DynAssMgmt.getEwmaStd     Function .  getEwmaStd(data::Array{Float64, 1}, persistenceVal::Float64)  EWMA estimator of standard deviation.  persistenceVal  defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation.  source  getEwmaStd(data::Array{Float64, 2}, persistenceVal::Float64)  source  getEwmaStd(data::TimeArray, persistenceVal::Float64)  source  getEwmaStd(data::Returns, persistenceVal::Float64)  source  #  DynAssMgmt.getEwmaCov     Function .  getEwmaCov(data::Array{Float64, 1}, persistenceVal::Float64)  EWMA estimator of covariance matrix.  persistenceVal  defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation.  source  getEwmaCov(data::TimeArray, persistenceVal::Float64)  source  getEwmaCov(data::Returns, persistenceVal::Float64)  source", 
            "title": "Functions"
        }, 
        {
            "location": "/types/universeTypes/", 
            "text": "Asset moments are concisely stored in special types.\n\n\n\n\nComposite types\n\n\n#\n\n\nDynAssMgmt.Univ\n \n \nType\n.\n\n\nUniv(mus::Array{Float64, 1}, covs::Array{Float64, 2}, retType::ReturnType)\n\n\n\n\nUniverse type, built on Float64 arrays. The universe specifies discrete asset moments: mus and covs.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.UnivEvol\n \n \nType\n.\n\n\nUnivEvol(manyUnivs::Array{Univ, 1}, manyDates::Array{Date, 1}, assetLabels::Array{String, 1})\n\n\n\n\nRobust implementation of series of universes. In contrast to a simple array of Univs, a UnivEvol also contains metadata like dates and asset names.\n\n\nsource\n\n\n\n\nFields of composite types\n\n\njulia\n using DynAssMgmt\n\njulia\n fieldnames(Univ)\n3-element Array{Symbol,1}:\n :mus\n :covs\n :retType\n\njulia\n fieldnames(UnivEvol)\n3-element Array{Symbol,1}:\n :universes\n :dates\n :assetLabels\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nDynAssMgmt.getInPercentages\n \n \nFunction\n.\n\n\ngetInPercentages(thisUniv::Univ)\n\n\n\n\nTransform values of universe into percentage scale if necessary.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.annualizeRiskReturn\n \n \nFunction\n.\n\n\nannualizeRiskReturn(mu::Float64, sig::Float64, retType::ReturnType)\n\n\n\n\nConvert risk and return values to annual scale.\n\n\nsource\n\n\nannualizeRiskReturn(mus::Array{Float64, 1}, sigs::Array{Float64, 1}, retType::ReturnType)\n\n\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.getMuInPercentages\n \n \nFunction\n.\n\n\ngetMuInPercentages(thisMu::Float64, retType::ReturnType)\n\n\n\n\nTransform value of expected return into percentage scale if necessary.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.getStdInPercentages\n \n \nFunction\n.\n\n\ngetStdInPercentages(thisStd::Float64, retType::ReturnType)\n\n\n\n\nTransform value of standard deviation into percentage scale if necessary.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.getUnivExtrema\n \n \nFunction\n.\n\n\ngetUnivExtrema(thisUniv::Univ)\n\n\n\n\nGet minimum and maximum values of mu and sigma for a given universe. Helpful to determine mu / sigma targets for investment strategies.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.getUnivEvolFromMatlabFormat\n \n \nFunction\n.\n\n\ngetUnivEvolFromMatlabFormat(muTab::DataFrame, covsTab::DataFrame)\n\n\n\n\nTransform Matlab long format of estimated moments into UnivEvol type.\n\n\nsource", 
            "title": "Asset moments"
        }, 
        {
            "location": "/types/universeTypes/#composite-types", 
            "text": "#  DynAssMgmt.Univ     Type .  Univ(mus::Array{Float64, 1}, covs::Array{Float64, 2}, retType::ReturnType)  Universe type, built on Float64 arrays. The universe specifies discrete asset moments: mus and covs.  source  #  DynAssMgmt.UnivEvol     Type .  UnivEvol(manyUnivs::Array{Univ, 1}, manyDates::Array{Date, 1}, assetLabels::Array{String, 1})  Robust implementation of series of universes. In contrast to a simple array of Univs, a UnivEvol also contains metadata like dates and asset names.  source", 
            "title": "Composite types"
        }, 
        {
            "location": "/types/universeTypes/#fields-of-composite-types", 
            "text": "julia  using DynAssMgmt\n\njulia  fieldnames(Univ)\n3-element Array{Symbol,1}:\n :mus\n :covs\n :retType\n\njulia  fieldnames(UnivEvol)\n3-element Array{Symbol,1}:\n :universes\n :dates\n :assetLabels", 
            "title": "Fields of composite types"
        }, 
        {
            "location": "/types/universeTypes/#functions", 
            "text": "#  DynAssMgmt.getInPercentages     Function .  getInPercentages(thisUniv::Univ)  Transform values of universe into percentage scale if necessary.  source  #  DynAssMgmt.annualizeRiskReturn     Function .  annualizeRiskReturn(mu::Float64, sig::Float64, retType::ReturnType)  Convert risk and return values to annual scale.  source  annualizeRiskReturn(mus::Array{Float64, 1}, sigs::Array{Float64, 1}, retType::ReturnType)  source  #  DynAssMgmt.getMuInPercentages     Function .  getMuInPercentages(thisMu::Float64, retType::ReturnType)  Transform value of expected return into percentage scale if necessary.  source  #  DynAssMgmt.getStdInPercentages     Function .  getStdInPercentages(thisStd::Float64, retType::ReturnType)  Transform value of standard deviation into percentage scale if necessary.  source  #  DynAssMgmt.getUnivExtrema     Function .  getUnivExtrema(thisUniv::Univ)  Get minimum and maximum values of mu and sigma for a given universe. Helpful to determine mu / sigma targets for investment strategies.  source  #  DynAssMgmt.getUnivEvolFromMatlabFormat     Function .  getUnivEvolFromMatlabFormat(muTab::DataFrame, covsTab::DataFrame)  Transform Matlab long format of estimated moments into UnivEvol type.  source", 
            "title": "Functions"
        }, 
        {
            "location": "/types/strategies/", 
            "text": "For given asset moments, there are several strategies to select an optimal portfolio.\n\n\n\n\nFields of composite types\n\n\njulia\n using DynAssMgmt\n\njulia\n fieldnames(GMVP)\n0-element Array{Symbol,1}\n\njulia\n fieldnames(TargetVola)\n1-element Array{Symbol,1}:\n :Vola\n\njulia\n fieldnames(RelativeTargetVola)\n1-element Array{Symbol,1}:\n :Vola\n\njulia\n fieldnames(MaxSharpe)\n1-element Array{Symbol,1}:\n :RiskFree\n\njulia\n fieldnames(TargetMu)\n1-element Array{Symbol,1}:\n :Mu\n\njulia\n fieldnames(EffFront)\n1-element Array{Symbol,1}:\n :NEffPfs\n\njulia\n fieldnames(DivFrontSigmaTarget)\n2-element Array{Symbol,1}:\n :diversTarget\n :sigTarget\n\njulia\n fieldnames(DivFront)\n2-element Array{Symbol,1}:\n :diversTarget\n :sigTargets\n\n\n\n\n\n\nSingle period strategies\n\n\n\n\nUsage\n\n\napply(thisTarget::SinglePeriodTarget, univHistory::UnivEvol)\n\n\n\n\n\n\nAbstract types\n\n\n#\n\n\nDynAssMgmt.SinglePeriodTarget\n \n \nType\n.\n\n\nSinglePeriodTarget\n\n\n\n\nAbstract super type for single-period strategies.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.SinglePeriodSpectrum\n \n \nType\n.\n\n\nSinglePeriodSpectrum\n\n\n\n\nAbstract super type for multiple single-period strategies in the cross-section.\n\n\nsource\n\n\n\n\nComposite types\n\n\n#\n\n\nDynAssMgmt.GMVP\n \n \nType\n.\n\n\nGMVP()\n\n\n\n\nGlobal minimum variance portfolio strategy.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.TargetVola\n \n \nType\n.\n\n\nTargetVola(vol::Float64)\n\n\n\n\nTarget portfolio volatility strategy.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.RelativeTargetVola\n \n \nType\n.\n\n\nRelativeTargetVola(vol::Float64)\n\n\n\n\nTarget portfolio volatility strategy, with volatility target given in relative terms. Target is relative with regards to maximum mu and gmvp.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.MaxSharpe\n \n \nType\n.\n\n\nMaxSharpe()\nMaxSharpe(rf::Float64)\n\n\n\n\nMaximum Sharpe-ratio portfolio strategy. Optional input can be used to specify the risk-free rate.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.TargetMu\n \n \nType\n.\n\n\nTargetMu(mu::Float64)\n\n\n\n\nTarget portfolio expectation strategy.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.EffFront\n \n \nType\n.\n\n\nEffFront(npfs::Int64)\n\n\n\n\nEfficient frontier portfolio spectrum. Single input determines the number of portfolios on the efficient frontier.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.DivFrontSigmaTarget\n \n \nType\n.\n\n\nDivFrontSigmaTarget(divTarget::Float64, sigTarget::Float64)\n\n\n\n\nPortfolio strategy with target diversification level and target volatility.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.DivFront\n \n \nType\n.\n\n\nDivFront(divTarget::Float64, sigTarget::Array{Float64, 1})\n\n\n\n\nMultiple portfolios with target diversification level and multiple volatility targets.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nDynAssMgmt.gmvp\n \n \nMethod\n.\n\n\ngmvp(thisUniv::Univ)\n\n\n\n\nGet global minimum variance portfolio without short-selling. Leverage is not allowed.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.gmvp_lev\n \n \nMethod\n.\n\n\ngmvp_lev(thisUniv::Univ)\n\n\n\n\nGet global minimum variance portfolio without any constraints on short-selling. In other words: leverage is allowed.\n\n\nsource", 
            "title": "Strategies"
        }, 
        {
            "location": "/types/strategies/#fields-of-composite-types", 
            "text": "julia  using DynAssMgmt\n\njulia  fieldnames(GMVP)\n0-element Array{Symbol,1}\n\njulia  fieldnames(TargetVola)\n1-element Array{Symbol,1}:\n :Vola\n\njulia  fieldnames(RelativeTargetVola)\n1-element Array{Symbol,1}:\n :Vola\n\njulia  fieldnames(MaxSharpe)\n1-element Array{Symbol,1}:\n :RiskFree\n\njulia  fieldnames(TargetMu)\n1-element Array{Symbol,1}:\n :Mu\n\njulia  fieldnames(EffFront)\n1-element Array{Symbol,1}:\n :NEffPfs\n\njulia  fieldnames(DivFrontSigmaTarget)\n2-element Array{Symbol,1}:\n :diversTarget\n :sigTarget\n\njulia  fieldnames(DivFront)\n2-element Array{Symbol,1}:\n :diversTarget\n :sigTargets", 
            "title": "Fields of composite types"
        }, 
        {
            "location": "/types/strategies/#single-period-strategies", 
            "text": "", 
            "title": "Single period strategies"
        }, 
        {
            "location": "/types/strategies/#usage", 
            "text": "apply(thisTarget::SinglePeriodTarget, univHistory::UnivEvol)", 
            "title": "Usage"
        }, 
        {
            "location": "/types/strategies/#abstract-types", 
            "text": "#  DynAssMgmt.SinglePeriodTarget     Type .  SinglePeriodTarget  Abstract super type for single-period strategies.  source  #  DynAssMgmt.SinglePeriodSpectrum     Type .  SinglePeriodSpectrum  Abstract super type for multiple single-period strategies in the cross-section.  source", 
            "title": "Abstract types"
        }, 
        {
            "location": "/types/strategies/#composite-types", 
            "text": "#  DynAssMgmt.GMVP     Type .  GMVP()  Global minimum variance portfolio strategy.  source  #  DynAssMgmt.TargetVola     Type .  TargetVola(vol::Float64)  Target portfolio volatility strategy.  source  #  DynAssMgmt.RelativeTargetVola     Type .  RelativeTargetVola(vol::Float64)  Target portfolio volatility strategy, with volatility target given in relative terms. Target is relative with regards to maximum mu and gmvp.  source  #  DynAssMgmt.MaxSharpe     Type .  MaxSharpe()\nMaxSharpe(rf::Float64)  Maximum Sharpe-ratio portfolio strategy. Optional input can be used to specify the risk-free rate.  source  #  DynAssMgmt.TargetMu     Type .  TargetMu(mu::Float64)  Target portfolio expectation strategy.  source  #  DynAssMgmt.EffFront     Type .  EffFront(npfs::Int64)  Efficient frontier portfolio spectrum. Single input determines the number of portfolios on the efficient frontier.  source  #  DynAssMgmt.DivFrontSigmaTarget     Type .  DivFrontSigmaTarget(divTarget::Float64, sigTarget::Float64)  Portfolio strategy with target diversification level and target volatility.  source  #  DynAssMgmt.DivFront     Type .  DivFront(divTarget::Float64, sigTarget::Array{Float64, 1})  Multiple portfolios with target diversification level and multiple volatility targets.  source", 
            "title": "Composite types"
        }, 
        {
            "location": "/types/strategies/#internal", 
            "text": "#  DynAssMgmt.gmvp     Method .  gmvp(thisUniv::Univ)  Get global minimum variance portfolio without short-selling. Leverage is not allowed.  source  #  DynAssMgmt.gmvp_lev     Method .  gmvp_lev(thisUniv::Univ)  Get global minimum variance portfolio without any constraints on short-selling. In other words: leverage is allowed.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/types/investmentTypes/", 
            "text": "Multiple optimal portfolios exist in cross-section as well as over time. \n\n\n#\n\n\nDynAssMgmt.PF\n \n \nType\n.\n\n\nPF(wgts::Array{Float64, 1})\n\n\n\n\nImplementation of a single portfolio. Weights have to be positive (short-selling is not allowed) and need to add up to 1.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.Invest\n \n \nType\n.\n\n\nInvest(pfs::Array{PF, 2}, spectrum::Array{SinglePeriodTarget, 1}, dates::Array{Date, 1}, assetLabels::Array{String, 1})\n\n\n\n\nImplementation of investments as collection of portfolios. Portfolios are equipped with additional descriptive meta-data: which strategies were used, which universe and which time period.\n\n\nsource\n\n\njulia\n using DynAssMgmt\n\njulia\n fieldnames(PF)\n1-element Array{Symbol,1}:\n :Wgts\n\njulia\n fieldnames(Invest)\n4-element Array{Symbol,1}:\n :pfs\n :strategies\n :dates\n :assetLabels\n\n\n\n\n\n\nPortfolio functions\n\n\n#\n\n\nDynAssMgmt.pfMoments\n \n \nMethod\n.\n\n\npfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, wgts::Array{Float64, 1}, riskType::String)\n\n\n\n\nCompute portfolio expectation and variance or standard deviation without any re-scaling or annualization. Allowed risk type keywords are \nstd\n and \nvar\n.\n\n\nSingle universe, single weights\n\n\npfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, wgts::Array{Float64, 1}, riskType::String)\npfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, pf::PF, riskType::String)\npfMoments(thisUniv::Univ, wgts::Array{Float64, 1}, riskType::String)\npfMoments(thisUniv::Univ, pf::PF, riskType::String)\n\n\n\n\nMultiple universes, single weights\n\n\npfMoments(univHist::UnivEvol, wgts::Array{Float64, 1}, riskType::String)\n\n\n\n\nSingle universe, multiple weights\n\n\npfMoments(univHist::Univ, pfWgts::Array{Array{Float64, 1}, 1}, riskType::String)\npfMoments(univHist::Univ, wgts::Array{Float64, 2}, riskType::String)\n\n\n\n\nMultiple universes, multiple weights\n\n\npfMoments(univHist::UnivEvol, wgts::Array{Float64, 2}, riskType::String)\n\n\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.pfDivers\n \n \nFunction\n.\n\n\npfDivers(wgts::Array{Float64, 1})\n\n\n\n\nCompute portfolio diversification as\n\n\n\n\n\n\\mathcal{D}=1 - \\sqrt{\\sum_{i=1}^{d}\\left|w_{i} - \\frac{1}{d}\\right|^2}\n\n\n\n\n\nsource\n\n\npfDivers(pf::PF)\n\n\n\n\nsource\n\n\npfDivers(pf::Array{PF, 1})\n\n\n\n\nsource\n\n\npfDivers(pf::Array{PF, 2})\n\n\n\n\nsource\n\n\npfDivers(invests::Invest)\n\n\n\n\nsource\n\n\npfDivers(allWgts::Array{Float64, 2})\n\n\n\n\nApplies to series of portfolio weights, with individual weights given in rows.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nDynAssMgmt.pfVariance\n \n \nFunction\n.\n\n\npfVariance(covs::Array{Float64, 2}, wgts::Array{Float64, 1})\n\n\n\n\nCompute the portfolio variance without any re-scaling or annualization.\n\n\nsource\n\n\n#\n\n\nDynAssMgmt.pfMu\n \n \nMethod\n.\n\n\npfMu(mus::Array{Float64, 1}, wgts::Array{Float64, 1})\n\n\n\n\nCompute the portfolio expectation without any re-scaling or annualization.\n\n\nsource", 
            "title": "Investments"
        }, 
        {
            "location": "/types/investmentTypes/#portfolio-functions", 
            "text": "#  DynAssMgmt.pfMoments     Method .  pfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, wgts::Array{Float64, 1}, riskType::String)  Compute portfolio expectation and variance or standard deviation without any re-scaling or annualization. Allowed risk type keywords are  std  and  var .  Single universe, single weights  pfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, wgts::Array{Float64, 1}, riskType::String)\npfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, pf::PF, riskType::String)\npfMoments(thisUniv::Univ, wgts::Array{Float64, 1}, riskType::String)\npfMoments(thisUniv::Univ, pf::PF, riskType::String)  Multiple universes, single weights  pfMoments(univHist::UnivEvol, wgts::Array{Float64, 1}, riskType::String)  Single universe, multiple weights  pfMoments(univHist::Univ, pfWgts::Array{Array{Float64, 1}, 1}, riskType::String)\npfMoments(univHist::Univ, wgts::Array{Float64, 2}, riskType::String)  Multiple universes, multiple weights  pfMoments(univHist::UnivEvol, wgts::Array{Float64, 2}, riskType::String)  source  #  DynAssMgmt.pfDivers     Function .  pfDivers(wgts::Array{Float64, 1})  Compute portfolio diversification as   \n\\mathcal{D}=1 - \\sqrt{\\sum_{i=1}^{d}\\left|w_{i} - \\frac{1}{d}\\right|^2}   source  pfDivers(pf::PF)  source  pfDivers(pf::Array{PF, 1})  source  pfDivers(pf::Array{PF, 2})  source  pfDivers(invests::Invest)  source  pfDivers(allWgts::Array{Float64, 2})  Applies to series of portfolio weights, with individual weights given in rows.  source", 
            "title": "Portfolio functions"
        }, 
        {
            "location": "/types/investmentTypes/#internal", 
            "text": "#  DynAssMgmt.pfVariance     Function .  pfVariance(covs::Array{Float64, 2}, wgts::Array{Float64, 1})  Compute the portfolio variance without any re-scaling or annualization.  source  #  DynAssMgmt.pfMu     Method .  pfMu(mus::Array{Float64, 1}, wgts::Array{Float64, 1})  Compute the portfolio expectation without any re-scaling or annualization.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/types/bktestTypes/", 
            "text": "Investments can be evaluated according to multiple key metrics. \n\n\nDynAssMgmt.Bktest", 
            "title": "Performance"
        }
    ]
}