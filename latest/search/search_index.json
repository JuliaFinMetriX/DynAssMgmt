{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DynAssMgmt.jl Documentation This package implements a framework to set up and test dynamic asset management strategies. Dynamic asset management types Utilities # DynAssMgmt.loadTestData Method . loadTestData(dataName::String) Load one of the predefined test data. fx / Fx: Garch dataset from Ecdat R package . Daily observations of exchange rate data from 1980\u201301 to 1987\u201305\u201321. Following exchange rates are part of it: dm: exchange rate Dollar/Deutsch Mark bp: exchange rate of Dollar/British Pound cd: exchange rate of Dollar/Canadian Dollar dy: exchange rate of Dollar/Yen sf: exchange rate of Dollar/Swiss Franc source Index DynAssMgmt.DivFront DynAssMgmt.DivFrontSigmaTarget DynAssMgmt.EWMA DynAssMgmt.EffFront DynAssMgmt.GMVP DynAssMgmt.Invest DynAssMgmt.MaxSharpe DynAssMgmt.PF DynAssMgmt.PerfStats DynAssMgmt.Performances DynAssMgmt.Prices DynAssMgmt.RelativeTargetVola DynAssMgmt.ReturnType DynAssMgmt.Returns DynAssMgmt.SinglePeriodSpectrum DynAssMgmt.SinglePeriodTarget DynAssMgmt.TargetMu DynAssMgmt.TargetVola DynAssMgmt.Univ DynAssMgmt.UnivEstimator DynAssMgmt.UnivEvol DynAssMgmt.aggregateReturns DynAssMgmt.annualizeRiskReturn DynAssMgmt.apply DynAssMgmt.applyOverTime DynAssMgmt.computeReturns DynAssMgmt.evalPerfStats DynAssMgmt.getDiscretePrices DynAssMgmt.getEwmaCov DynAssMgmt.getEwmaMean DynAssMgmt.getEwmaStd DynAssMgmt.getInPercentages DynAssMgmt.getLogPrices DynAssMgmt.getMuInPercentages DynAssMgmt.getStdInPercentages DynAssMgmt.getUnivEvolFromMatlabFormat DynAssMgmt.getUnivExtrema DynAssMgmt.gmvp DynAssMgmt.gmvp_lev DynAssMgmt.loadTestData DynAssMgmt.locf DynAssMgmt.locf! DynAssMgmt.nocb DynAssMgmt.nocb! DynAssMgmt.normalizePrices DynAssMgmt.pfDivers DynAssMgmt.pfMoments DynAssMgmt.pfMu DynAssMgmt.pfVariance DynAssMgmt.rets2prices DynAssMgmt.standardize","title":"Introduction"},{"location":"#dynassmgmtjl-documentation","text":"This package implements a framework to set up and test dynamic asset management strategies.","title":"DynAssMgmt.jl Documentation"},{"location":"#dynamic-asset-management-types","text":"","title":"Dynamic asset management types"},{"location":"#utilities","text":"# DynAssMgmt.loadTestData Method . loadTestData(dataName::String) Load one of the predefined test data. fx / Fx: Garch dataset from Ecdat R package . Daily observations of exchange rate data from 1980\u201301 to 1987\u201305\u201321. Following exchange rates are part of it: dm: exchange rate Dollar/Deutsch Mark bp: exchange rate of Dollar/British Pound cd: exchange rate of Dollar/Canadian Dollar dy: exchange rate of Dollar/Yen sf: exchange rate of Dollar/Swiss Franc source","title":"Utilities"},{"location":"#index","text":"DynAssMgmt.DivFront DynAssMgmt.DivFrontSigmaTarget DynAssMgmt.EWMA DynAssMgmt.EffFront DynAssMgmt.GMVP DynAssMgmt.Invest DynAssMgmt.MaxSharpe DynAssMgmt.PF DynAssMgmt.PerfStats DynAssMgmt.Performances DynAssMgmt.Prices DynAssMgmt.RelativeTargetVola DynAssMgmt.ReturnType DynAssMgmt.Returns DynAssMgmt.SinglePeriodSpectrum DynAssMgmt.SinglePeriodTarget DynAssMgmt.TargetMu DynAssMgmt.TargetVola DynAssMgmt.Univ DynAssMgmt.UnivEstimator DynAssMgmt.UnivEvol DynAssMgmt.aggregateReturns DynAssMgmt.annualizeRiskReturn DynAssMgmt.apply DynAssMgmt.applyOverTime DynAssMgmt.computeReturns DynAssMgmt.evalPerfStats DynAssMgmt.getDiscretePrices DynAssMgmt.getEwmaCov DynAssMgmt.getEwmaMean DynAssMgmt.getEwmaStd DynAssMgmt.getInPercentages DynAssMgmt.getLogPrices DynAssMgmt.getMuInPercentages DynAssMgmt.getStdInPercentages DynAssMgmt.getUnivEvolFromMatlabFormat DynAssMgmt.getUnivExtrema DynAssMgmt.gmvp DynAssMgmt.gmvp_lev DynAssMgmt.loadTestData DynAssMgmt.locf DynAssMgmt.locf! DynAssMgmt.nocb DynAssMgmt.nocb! DynAssMgmt.normalizePrices DynAssMgmt.pfDivers DynAssMgmt.pfMoments DynAssMgmt.pfMu DynAssMgmt.pfVariance DynAssMgmt.rets2prices DynAssMgmt.standardize","title":"Index"},{"location":"types/bktestTypes/","text":"Investments can be evaluated according to multiple key metrics. # DynAssMgmt.PerfStats Type . PerfStats(vals::Array{Float64, 1}, statNams::Array{Symbol, 1}) Performance statistics type, collecting risk / return metrics for single realized portfolio price path. source Fields of composite types julia using DynAssMgmt julia fieldnames(PerfStats) 9-element Array{Symbol,1}: :FullPercRet :SpMuPerc :SpSigmaPerc :MuDailyToAnnualPerc :SigmaDailyToAnnualPerc :SpVaRPerc :MaxDD :VaR :GeoMean Functions evalPerf evalDdowns evalPerfStats","title":"Performance"},{"location":"types/bktestTypes/#fields-of-composite-types","text":"julia using DynAssMgmt julia fieldnames(PerfStats) 9-element Array{Symbol,1}: :FullPercRet :SpMuPerc :SpSigmaPerc :MuDailyToAnnualPerc :SigmaDailyToAnnualPerc :SpVaRPerc :MaxDD :VaR :GeoMean","title":"Fields of composite types"},{"location":"types/bktestTypes/#functions","text":"evalPerf evalDdowns evalPerfStats","title":"Functions"},{"location":"types/dataTypes/","text":"Return data should always come with additional meta-data to explicitly determine return properties. Therefore, the following data types exist. Composite types # DynAssMgmt.ReturnType Type . ReturnType(isPercent::Bool, isLog::Bool, period::Dates.DatePeriod, isGross::Bool) Specification of return type. Returns could differ with regards to following properties: fractional / percentage returns discrete / logarithmic returns daily, monthly, yearly, ... returns net / gross returns Standard return type is fractional , discrete , net daily returns. source # DynAssMgmt.Returns Type . Returns(data::TimeSeries.TimeArray, retType::ReturnType) Data type to store return data together with meta-data. source # DynAssMgmt.Prices Type . Prices(data::TimeSeries.TimeArray, isLog::Bool) Data type to store prices together with meta-data. This basically allows to robustly identify logarithmic prices. source # DynAssMgmt.Performances Type . Performance(data::TimeSeries.TimeArray, retType::ReturnType) Data type to store performance data together with meta-data. Performance basically can be interpreted as aggregated returns. For the special case of gross performance values, performances also can be interpreted as normalized prices. source Fields of composite types julia using DynAssMgmt julia fieldnames(ReturnType) 4-element Array{Symbol,1}: :isPercent :isLog :period :isGross julia fieldnames(Returns) 2-element Array{Symbol,1}: :data :retType julia fieldnames(Prices) 2-element Array{Symbol,1}: :data :isLog julia fieldnames(Performances) 2-element Array{Symbol,1}: :data :retType Price and return data handling For each data type, there exist several different scales in which the data could be given. For example, prices can be regular discrete prices, or logarithmic prices. Similarly, performances can be measured in percentages and discrete or logarithmic. For each data type, however, there exists a default scale in which any given instance can be translated using function standardize . # DynAssMgmt.standardize Function . standardize(rets::Returns) Convert return data to default return type: fractional , discrete and net returns. source standardize(prices::Prices) Convert price data to default price type: discrete, not logarithmic prices. source standardize(perfs::Performances) Convert performance data to default performance type: fractional , discrete and net performances. source Defining conversion methods from any possible data scale to this default scale will allow conversion between any arbitrary scales. For example, for Prices the following methods exist: # DynAssMgmt.getLogPrices Function . getLogPrices(prices::Prices) Transform prices to logarithmic prices if necessary. source # DynAssMgmt.getDiscretePrices Function . getDiscretePrices(prices::Prices) Transform prices to discrete values if necessary. source # DynAssMgmt.normalizePrices Function . normalizePrices(xx::Array{Float64, 1}) Rescale prices such that first observation starts at 1. source normalizePrices(xx::Array{Float64, 2}) source normalizePrices(xx::TimeArray) source normalizePrices(xx::Prices) source As Returns , Prices and Performances are closely interconnected, there also exist default conversion methods between them. These methods make use of the following low-level functions: # DynAssMgmt.computeReturns Function . computeReturns(prices::Array{Float64, 1}, retType = ReturnType()) Compute returns from prices. The function uses default settings for return calculations: discrete returns (not logarithmic) fractional returns (not percentage) single-period returns (not multi-period) net returns (not gross returns) straight-forward application to NaN s also source computeReturns(prices::Array{Float64, 2}, retType = ReturnType()) source computeReturns(xx::TimeSeries.TimeArray, retType = ReturnType()) source # DynAssMgmt.aggregateReturns Function . aggregateReturns(rets::Array{Float64, 1}, retType::ReturnType, prependStart=false) Aggregate returns to performances (not prices). The function uses default types of returns: discrete returns (not logarithmic) fractional returns (not percentage) single-period returns (not multi-period) net returns (not gross returns) convention for how to deal with NaN s still needs to be defined source aggregateReturns(discRets::Array{Float64, 2}, retType::ReturnType, prependStart=false) source aggregateReturns(discRets::TimeSeries.TimeArray, retType::ReturnType, prependStart=false) source aggregateReturns(rets::Returns, prependStart=false) source # DynAssMgmt.rets2prices Function . rets2prices(rets::Array{Float64, 1}, retType::ReturnType, startPrice=1., prependStart=false) Aggregate returns to prices (not performances). The function uses default types of returns: discrete returns (not logarithmic) fractional returns (not percentage) single-period returns (not multi-period) net returns (not gross returns) convention for how to deal with NaN s still needs to be defined source rets2prices(rets::Array{Float64, 2}, retType::ReturnType) source rets2prices(rets::TimeSeries.TimeArray, retType::ReturnType, startPrice=1., prependStart=false) source rets2prices(rets::Returns, startPrice=1., prependStart=false) source Data imputation # DynAssMgmt.locf! Function . locf!(xx::Array{Float64, 1}) Replacing NaN according to last observation carried forward . source # DynAssMgmt.locf Function . locf(xx::Array{Float64, 1}) Replacing NaN according to last observation carried forward . source locf(xx::Array{Float64, 2}) source locf(xx::TimeArray) source # DynAssMgmt.nocb! Function . nocb!(xx::Array{Float64, 1}) Replacing NaN according to next observation carried backward . source # DynAssMgmt.nocb Function . nocb(xx::Array{Float64, 1}) Replacing NaN according to next observation carried backward . source nocb(xx::Array{Float64, 2}) source nocb(xx::TimeArray) source","title":"Return data"},{"location":"types/dataTypes/#composite-types","text":"# DynAssMgmt.ReturnType Type . ReturnType(isPercent::Bool, isLog::Bool, period::Dates.DatePeriod, isGross::Bool) Specification of return type. Returns could differ with regards to following properties: fractional / percentage returns discrete / logarithmic returns daily, monthly, yearly, ... returns net / gross returns Standard return type is fractional , discrete , net daily returns. source # DynAssMgmt.Returns Type . Returns(data::TimeSeries.TimeArray, retType::ReturnType) Data type to store return data together with meta-data. source # DynAssMgmt.Prices Type . Prices(data::TimeSeries.TimeArray, isLog::Bool) Data type to store prices together with meta-data. This basically allows to robustly identify logarithmic prices. source # DynAssMgmt.Performances Type . Performance(data::TimeSeries.TimeArray, retType::ReturnType) Data type to store performance data together with meta-data. Performance basically can be interpreted as aggregated returns. For the special case of gross performance values, performances also can be interpreted as normalized prices. source","title":"Composite types"},{"location":"types/dataTypes/#fields-of-composite-types","text":"julia using DynAssMgmt julia fieldnames(ReturnType) 4-element Array{Symbol,1}: :isPercent :isLog :period :isGross julia fieldnames(Returns) 2-element Array{Symbol,1}: :data :retType julia fieldnames(Prices) 2-element Array{Symbol,1}: :data :isLog julia fieldnames(Performances) 2-element Array{Symbol,1}: :data :retType","title":"Fields of composite types"},{"location":"types/dataTypes/#price-and-return-data-handling","text":"For each data type, there exist several different scales in which the data could be given. For example, prices can be regular discrete prices, or logarithmic prices. Similarly, performances can be measured in percentages and discrete or logarithmic. For each data type, however, there exists a default scale in which any given instance can be translated using function standardize . # DynAssMgmt.standardize Function . standardize(rets::Returns) Convert return data to default return type: fractional , discrete and net returns. source standardize(prices::Prices) Convert price data to default price type: discrete, not logarithmic prices. source standardize(perfs::Performances) Convert performance data to default performance type: fractional , discrete and net performances. source Defining conversion methods from any possible data scale to this default scale will allow conversion between any arbitrary scales. For example, for Prices the following methods exist: # DynAssMgmt.getLogPrices Function . getLogPrices(prices::Prices) Transform prices to logarithmic prices if necessary. source # DynAssMgmt.getDiscretePrices Function . getDiscretePrices(prices::Prices) Transform prices to discrete values if necessary. source # DynAssMgmt.normalizePrices Function . normalizePrices(xx::Array{Float64, 1}) Rescale prices such that first observation starts at 1. source normalizePrices(xx::Array{Float64, 2}) source normalizePrices(xx::TimeArray) source normalizePrices(xx::Prices) source As Returns , Prices and Performances are closely interconnected, there also exist default conversion methods between them. These methods make use of the following low-level functions: # DynAssMgmt.computeReturns Function . computeReturns(prices::Array{Float64, 1}, retType = ReturnType()) Compute returns from prices. The function uses default settings for return calculations: discrete returns (not logarithmic) fractional returns (not percentage) single-period returns (not multi-period) net returns (not gross returns) straight-forward application to NaN s also source computeReturns(prices::Array{Float64, 2}, retType = ReturnType()) source computeReturns(xx::TimeSeries.TimeArray, retType = ReturnType()) source # DynAssMgmt.aggregateReturns Function . aggregateReturns(rets::Array{Float64, 1}, retType::ReturnType, prependStart=false) Aggregate returns to performances (not prices). The function uses default types of returns: discrete returns (not logarithmic) fractional returns (not percentage) single-period returns (not multi-period) net returns (not gross returns) convention for how to deal with NaN s still needs to be defined source aggregateReturns(discRets::Array{Float64, 2}, retType::ReturnType, prependStart=false) source aggregateReturns(discRets::TimeSeries.TimeArray, retType::ReturnType, prependStart=false) source aggregateReturns(rets::Returns, prependStart=false) source # DynAssMgmt.rets2prices Function . rets2prices(rets::Array{Float64, 1}, retType::ReturnType, startPrice=1., prependStart=false) Aggregate returns to prices (not performances). The function uses default types of returns: discrete returns (not logarithmic) fractional returns (not percentage) single-period returns (not multi-period) net returns (not gross returns) convention for how to deal with NaN s still needs to be defined source rets2prices(rets::Array{Float64, 2}, retType::ReturnType) source rets2prices(rets::TimeSeries.TimeArray, retType::ReturnType, startPrice=1., prependStart=false) source rets2prices(rets::Returns, startPrice=1., prependStart=false) source","title":"Price and return data handling"},{"location":"types/dataTypes/#data-imputation","text":"# DynAssMgmt.locf! Function . locf!(xx::Array{Float64, 1}) Replacing NaN according to last observation carried forward . source # DynAssMgmt.locf Function . locf(xx::Array{Float64, 1}) Replacing NaN according to last observation carried forward . source locf(xx::Array{Float64, 2}) source locf(xx::TimeArray) source # DynAssMgmt.nocb! Function . nocb!(xx::Array{Float64, 1}) Replacing NaN according to next observation carried backward . source # DynAssMgmt.nocb Function . nocb(xx::Array{Float64, 1}) Replacing NaN according to next observation carried backward . source nocb(xx::Array{Float64, 2}) source nocb(xx::TimeArray) source","title":"Data imputation"},{"location":"types/estimatorTypes/","text":"Asset moments can be estimated according to a couple of ways. Abstract types # DynAssMgmt.UnivEstimator Type . UnivEstimator Abstract super type for asset moment estimators. source Estimators # DynAssMgmt.EWMA Type . EWMA(muPersistence::Float64, covPersistence::Float64) Exponential weighted moving average estimator of asset moments. muPersistence is the lambda value of the estimator of mean asset returns, and covPersistence is the lambda value for the covariance matrix. source Fields of composite types julia using DynAssMgmt julia fieldnames(EWMA) 2-element Array{Symbol,1}: :muPersistence :covPersistence Usage # DynAssMgmt.apply Method . apply(thisEstimator::UnivEstimator, rets::Returns) Apply some moment estimator to return data. In the background, apply needs to be defined for each possible estimator. source # DynAssMgmt.applyOverTime Function . applyOverTime(thisEstimator::UnivEstimator, retsData::Returns, minObs::Int) Successively apply given moment estimator to return data. minObs determines the minimum number of observations. This bascially defines the first subsample where the estimator will be applied. source Functions # DynAssMgmt.getEwmaMean Function . getEwmaMean(data::Array{Float64, 1}, persistenceVal::Float64) EWMA estimator of expected value. persistenceVal defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation. source getEwmaMean(data::Array{Float64, 2}, persistenceVal::Float64) source getEwmaMean(data::TimeArray, persistenceVal::Float64) source getEwmaMean(data::Returns, persistenceVal::Float64) source # DynAssMgmt.getEwmaStd Function . getEwmaStd(data::Array{Float64, 1}, persistenceVal::Float64) EWMA estimator of standard deviation. persistenceVal defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation. source getEwmaStd(data::Array{Float64, 2}, persistenceVal::Float64) source getEwmaStd(data::TimeArray, persistenceVal::Float64) source getEwmaStd(data::Returns, persistenceVal::Float64) source # DynAssMgmt.getEwmaCov Function . getEwmaCov(data::Array{Float64, 1}, persistenceVal::Float64) EWMA estimator of covariance matrix. persistenceVal defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation. source getEwmaCov(data::TimeArray, persistenceVal::Float64) source getEwmaCov(data::Returns, persistenceVal::Float64) source","title":"Moment estimators"},{"location":"types/estimatorTypes/#abstract-types","text":"# DynAssMgmt.UnivEstimator Type . UnivEstimator Abstract super type for asset moment estimators. source","title":"Abstract types"},{"location":"types/estimatorTypes/#estimators","text":"# DynAssMgmt.EWMA Type . EWMA(muPersistence::Float64, covPersistence::Float64) Exponential weighted moving average estimator of asset moments. muPersistence is the lambda value of the estimator of mean asset returns, and covPersistence is the lambda value for the covariance matrix. source","title":"Estimators"},{"location":"types/estimatorTypes/#fields-of-composite-types","text":"julia using DynAssMgmt julia fieldnames(EWMA) 2-element Array{Symbol,1}: :muPersistence :covPersistence","title":"Fields of composite types"},{"location":"types/estimatorTypes/#usage","text":"# DynAssMgmt.apply Method . apply(thisEstimator::UnivEstimator, rets::Returns) Apply some moment estimator to return data. In the background, apply needs to be defined for each possible estimator. source # DynAssMgmt.applyOverTime Function . applyOverTime(thisEstimator::UnivEstimator, retsData::Returns, minObs::Int) Successively apply given moment estimator to return data. minObs determines the minimum number of observations. This bascially defines the first subsample where the estimator will be applied. source","title":"Usage"},{"location":"types/estimatorTypes/#functions","text":"# DynAssMgmt.getEwmaMean Function . getEwmaMean(data::Array{Float64, 1}, persistenceVal::Float64) EWMA estimator of expected value. persistenceVal defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation. source getEwmaMean(data::Array{Float64, 2}, persistenceVal::Float64) source getEwmaMean(data::TimeArray, persistenceVal::Float64) source getEwmaMean(data::Returns, persistenceVal::Float64) source # DynAssMgmt.getEwmaStd Function . getEwmaStd(data::Array{Float64, 1}, persistenceVal::Float64) EWMA estimator of standard deviation. persistenceVal defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation. source getEwmaStd(data::Array{Float64, 2}, persistenceVal::Float64) source getEwmaStd(data::TimeArray, persistenceVal::Float64) source getEwmaStd(data::Returns, persistenceVal::Float64) source # DynAssMgmt.getEwmaCov Function . getEwmaCov(data::Array{Float64, 1}, persistenceVal::Float64) EWMA estimator of covariance matrix. persistenceVal defines how much weight historic observations get, and hence implicitly also defines the weight of the most recent observation. source getEwmaCov(data::TimeArray, persistenceVal::Float64) source getEwmaCov(data::Returns, persistenceVal::Float64) source","title":"Functions"},{"location":"types/investmentTypes/","text":"Multiple optimal portfolios exist in cross-section as well as over time. # DynAssMgmt.PF Type . PF(wgts::Array{Float64, 1}) Implementation of a single portfolio. Weights have to be positive (short-selling is not allowed) and need to add up to 1. source # DynAssMgmt.Invest Type . Invest(pfs::Array{PF, 2}, spectrum::Array{SinglePeriodTarget, 1}, dates::Array{Date, 1}, assetLabels::Array{String, 1}, stratLabels::Array{String, 1}) Implementation of investments as collection of portfolios. Portfolios are equipped with additional descriptive meta-data: which strategies were used, which universe and which time period. source julia using DynAssMgmt julia fieldnames(PF) 1-element Array{Symbol,1}: :Wgts julia fieldnames(Invest) 5-element Array{Symbol,1}: :pfs :strategies :dates :assetLabels :stratLabels Portfolio functions # DynAssMgmt.pfMoments Method . pfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, wgts::Array{Float64, 1}, riskType::String) Compute portfolio expectation and variance or standard deviation without any re-scaling or annualization. Allowed risk type keywords are std and var . Single universe, single weights pfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, wgts::Array{Float64, 1}, riskType::String) pfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, pf::PF, riskType::String) pfMoments(thisUniv::Univ, wgts::Array{Float64, 1}, riskType::String) pfMoments(thisUniv::Univ, pf::PF, riskType::String) Multiple universes, single weights pfMoments(univHist::UnivEvol, wgts::Array{Float64, 1}, riskType::String) Single universe, multiple weights pfMoments(univHist::Univ, pfWgts::Array{Array{Float64, 1}, 1}, riskType::String) pfMoments(univHist::Univ, wgts::Array{Float64, 2}, riskType::String) Multiple universes, multiple weights pfMoments(univHist::UnivEvol, wgts::Array{Float64, 2}, riskType::String) source # DynAssMgmt.pfDivers Function . pfDivers(wgts::Array{Float64, 1}) Compute portfolio diversification as \\mathcal{D}=1 - \\sqrt{\\sum_{i=1}^{d}\\left|w_{i} - \\frac{1}{d}\\right|^2} source pfDivers(pf::PF) source pfDivers(pf::Array{PF, 1}) source pfDivers(pf::Array{PF, 2}) source pfDivers(invests::Invest) source pfDivers(allWgts::Array{Float64, 2}) Applies to series of portfolio weights, with individual weights given in rows. source Internal # DynAssMgmt.pfVariance Function . pfVariance(covs::Array{Float64, 2}, wgts::Array{Float64, 1}) Compute the portfolio variance without any re-scaling or annualization. source # DynAssMgmt.pfMu Method . pfMu(mus::Array{Float64, 1}, wgts::Array{Float64, 1}) Compute the portfolio expectation without any re-scaling or annualization. source","title":"Investments"},{"location":"types/investmentTypes/#portfolio-functions","text":"# DynAssMgmt.pfMoments Method . pfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, wgts::Array{Float64, 1}, riskType::String) Compute portfolio expectation and variance or standard deviation without any re-scaling or annualization. Allowed risk type keywords are std and var . Single universe, single weights pfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, wgts::Array{Float64, 1}, riskType::String) pfMoments(mus::Array{Float64, 1}, covs::Array{Float64, 2}, pf::PF, riskType::String) pfMoments(thisUniv::Univ, wgts::Array{Float64, 1}, riskType::String) pfMoments(thisUniv::Univ, pf::PF, riskType::String) Multiple universes, single weights pfMoments(univHist::UnivEvol, wgts::Array{Float64, 1}, riskType::String) Single universe, multiple weights pfMoments(univHist::Univ, pfWgts::Array{Array{Float64, 1}, 1}, riskType::String) pfMoments(univHist::Univ, wgts::Array{Float64, 2}, riskType::String) Multiple universes, multiple weights pfMoments(univHist::UnivEvol, wgts::Array{Float64, 2}, riskType::String) source # DynAssMgmt.pfDivers Function . pfDivers(wgts::Array{Float64, 1}) Compute portfolio diversification as \\mathcal{D}=1 - \\sqrt{\\sum_{i=1}^{d}\\left|w_{i} - \\frac{1}{d}\\right|^2} source pfDivers(pf::PF) source pfDivers(pf::Array{PF, 1}) source pfDivers(pf::Array{PF, 2}) source pfDivers(invests::Invest) source pfDivers(allWgts::Array{Float64, 2}) Applies to series of portfolio weights, with individual weights given in rows. source","title":"Portfolio functions"},{"location":"types/investmentTypes/#internal","text":"# DynAssMgmt.pfVariance Function . pfVariance(covs::Array{Float64, 2}, wgts::Array{Float64, 1}) Compute the portfolio variance without any re-scaling or annualization. source # DynAssMgmt.pfMu Method . pfMu(mus::Array{Float64, 1}, wgts::Array{Float64, 1}) Compute the portfolio expectation without any re-scaling or annualization. source","title":"Internal"},{"location":"types/strategies/","text":"For given asset moments, there are several strategies to select an optimal portfolio. Fields of composite types julia using DynAssMgmt julia fieldnames(GMVP) 0-element Array{Symbol,1} julia fieldnames(TargetVola) 1-element Array{Symbol,1}: :Vola julia fieldnames(RelativeTargetVola) 1-element Array{Symbol,1}: :Vola julia fieldnames(MaxSharpe) 1-element Array{Symbol,1}: :RiskFree julia fieldnames(TargetMu) 1-element Array{Symbol,1}: :Mu julia fieldnames(EffFront) 1-element Array{Symbol,1}: :NEffPfs julia fieldnames(DivFrontSigmaTarget) 2-element Array{Symbol,1}: :diversTarget :sigTarget julia fieldnames(DivFront) 2-element Array{Symbol,1}: :diversTarget :sigTargets Single period strategies Usage apply(thisTarget::SinglePeriodTarget, univHistory::UnivEvol) Abstract types # DynAssMgmt.SinglePeriodTarget Type . SinglePeriodTarget Abstract super type for single-period strategies. source # DynAssMgmt.SinglePeriodSpectrum Type . SinglePeriodSpectrum Abstract super type for multiple single-period strategies in the cross-section. source Composite types # DynAssMgmt.GMVP Type . GMVP() Global minimum variance portfolio strategy. source # DynAssMgmt.TargetVola Type . TargetVola(vol::Float64) Target portfolio volatility strategy. source # DynAssMgmt.RelativeTargetVola Type . RelativeTargetVola(vol::Float64) Target portfolio volatility strategy, with volatility target given in relative terms. Target is relative with regards to maximum mu and gmvp. source # DynAssMgmt.MaxSharpe Type . MaxSharpe() MaxSharpe(rf::Float64) Maximum Sharpe-ratio portfolio strategy. Optional input can be used to specify the risk-free rate. source # DynAssMgmt.TargetMu Type . TargetMu(mu::Float64) Target portfolio expectation strategy. source # DynAssMgmt.EffFront Type . EffFront(npfs::Int64) Efficient frontier portfolio spectrum. Single input determines the number of portfolios on the efficient frontier. source # DynAssMgmt.DivFrontSigmaTarget Type . DivFrontSigmaTarget(divTarget::Float64, sigTarget::Float64) Portfolio strategy with target diversification level and target volatility. source # DynAssMgmt.DivFront Type . DivFront(divTarget::Float64, sigTarget::Array{Float64, 1}) Multiple portfolios with target diversification level and multiple volatility targets. source Internal # DynAssMgmt.gmvp Method . gmvp(thisUniv::Univ) Get global minimum variance portfolio without short-selling. Leverage is not allowed. source # DynAssMgmt.gmvp_lev Method . gmvp_lev(thisUniv::Univ) Get global minimum variance portfolio without any constraints on short-selling. In other words: leverage is allowed. source","title":"Strategies"},{"location":"types/strategies/#fields-of-composite-types","text":"julia using DynAssMgmt julia fieldnames(GMVP) 0-element Array{Symbol,1} julia fieldnames(TargetVola) 1-element Array{Symbol,1}: :Vola julia fieldnames(RelativeTargetVola) 1-element Array{Symbol,1}: :Vola julia fieldnames(MaxSharpe) 1-element Array{Symbol,1}: :RiskFree julia fieldnames(TargetMu) 1-element Array{Symbol,1}: :Mu julia fieldnames(EffFront) 1-element Array{Symbol,1}: :NEffPfs julia fieldnames(DivFrontSigmaTarget) 2-element Array{Symbol,1}: :diversTarget :sigTarget julia fieldnames(DivFront) 2-element Array{Symbol,1}: :diversTarget :sigTargets","title":"Fields of composite types"},{"location":"types/strategies/#single-period-strategies","text":"","title":"Single period strategies"},{"location":"types/strategies/#usage","text":"apply(thisTarget::SinglePeriodTarget, univHistory::UnivEvol)","title":"Usage"},{"location":"types/strategies/#abstract-types","text":"# DynAssMgmt.SinglePeriodTarget Type . SinglePeriodTarget Abstract super type for single-period strategies. source # DynAssMgmt.SinglePeriodSpectrum Type . SinglePeriodSpectrum Abstract super type for multiple single-period strategies in the cross-section. source","title":"Abstract types"},{"location":"types/strategies/#composite-types","text":"# DynAssMgmt.GMVP Type . GMVP() Global minimum variance portfolio strategy. source # DynAssMgmt.TargetVola Type . TargetVola(vol::Float64) Target portfolio volatility strategy. source # DynAssMgmt.RelativeTargetVola Type . RelativeTargetVola(vol::Float64) Target portfolio volatility strategy, with volatility target given in relative terms. Target is relative with regards to maximum mu and gmvp. source # DynAssMgmt.MaxSharpe Type . MaxSharpe() MaxSharpe(rf::Float64) Maximum Sharpe-ratio portfolio strategy. Optional input can be used to specify the risk-free rate. source # DynAssMgmt.TargetMu Type . TargetMu(mu::Float64) Target portfolio expectation strategy. source # DynAssMgmt.EffFront Type . EffFront(npfs::Int64) Efficient frontier portfolio spectrum. Single input determines the number of portfolios on the efficient frontier. source # DynAssMgmt.DivFrontSigmaTarget Type . DivFrontSigmaTarget(divTarget::Float64, sigTarget::Float64) Portfolio strategy with target diversification level and target volatility. source # DynAssMgmt.DivFront Type . DivFront(divTarget::Float64, sigTarget::Array{Float64, 1}) Multiple portfolios with target diversification level and multiple volatility targets. source","title":"Composite types"},{"location":"types/strategies/#internal","text":"# DynAssMgmt.gmvp Method . gmvp(thisUniv::Univ) Get global minimum variance portfolio without short-selling. Leverage is not allowed. source # DynAssMgmt.gmvp_lev Method . gmvp_lev(thisUniv::Univ) Get global minimum variance portfolio without any constraints on short-selling. In other words: leverage is allowed. source","title":"Internal"},{"location":"types/universeTypes/","text":"Asset moments are concisely stored in special types. Composite types # DynAssMgmt.Univ Type . Univ(mus::Array{Float64, 1}, covs::Array{Float64, 2}, retType::ReturnType) Universe type, built on Float64 arrays. The universe specifies discrete asset moments: mus and covs. source # DynAssMgmt.UnivEvol Type . UnivEvol(manyUnivs::Array{Univ, 1}, manyDates::Array{Date, 1}, assetLabels::Array{String, 1}) Robust implementation of series of universes. In contrast to a simple array of Univs, a UnivEvol also contains metadata like dates and asset names. source Fields of composite types julia using DynAssMgmt julia fieldnames(Univ) 3-element Array{Symbol,1}: :mus :covs :retType julia fieldnames(UnivEvol) 3-element Array{Symbol,1}: :universes :dates :assetLabels Functions # DynAssMgmt.getInPercentages Function . getInPercentages(thisUniv::Univ) Transform values of universe into percentage scale if necessary. source # DynAssMgmt.annualizeRiskReturn Function . annualizeRiskReturn(mu::Float64, sig::Float64, retType::ReturnType) Convert risk and return values to annual scale. source annualizeRiskReturn(mus::Array{Float64, 1}, sigs::Array{Float64, 1}, retType::ReturnType) source # DynAssMgmt.getMuInPercentages Function . getMuInPercentages(thisMu::Float64, retType::ReturnType) Transform value of expected return into percentage scale if necessary. source # DynAssMgmt.getStdInPercentages Function . getStdInPercentages(thisStd::Float64, retType::ReturnType) Transform value of standard deviation into percentage scale if necessary. source # DynAssMgmt.getUnivExtrema Function . getUnivExtrema(thisUniv::Univ) Get minimum and maximum values of mu and sigma for a given universe. Helpful to determine mu / sigma targets for investment strategies. source # DynAssMgmt.getUnivEvolFromMatlabFormat Function . getUnivEvolFromMatlabFormat(muTab::DataFrame, covsTab::DataFrame) Transform Matlab long format of estimated moments into UnivEvol type. source","title":"Asset moments"},{"location":"types/universeTypes/#composite-types","text":"# DynAssMgmt.Univ Type . Univ(mus::Array{Float64, 1}, covs::Array{Float64, 2}, retType::ReturnType) Universe type, built on Float64 arrays. The universe specifies discrete asset moments: mus and covs. source # DynAssMgmt.UnivEvol Type . UnivEvol(manyUnivs::Array{Univ, 1}, manyDates::Array{Date, 1}, assetLabels::Array{String, 1}) Robust implementation of series of universes. In contrast to a simple array of Univs, a UnivEvol also contains metadata like dates and asset names. source","title":"Composite types"},{"location":"types/universeTypes/#fields-of-composite-types","text":"julia using DynAssMgmt julia fieldnames(Univ) 3-element Array{Symbol,1}: :mus :covs :retType julia fieldnames(UnivEvol) 3-element Array{Symbol,1}: :universes :dates :assetLabels","title":"Fields of composite types"},{"location":"types/universeTypes/#functions","text":"# DynAssMgmt.getInPercentages Function . getInPercentages(thisUniv::Univ) Transform values of universe into percentage scale if necessary. source # DynAssMgmt.annualizeRiskReturn Function . annualizeRiskReturn(mu::Float64, sig::Float64, retType::ReturnType) Convert risk and return values to annual scale. source annualizeRiskReturn(mus::Array{Float64, 1}, sigs::Array{Float64, 1}, retType::ReturnType) source # DynAssMgmt.getMuInPercentages Function . getMuInPercentages(thisMu::Float64, retType::ReturnType) Transform value of expected return into percentage scale if necessary. source # DynAssMgmt.getStdInPercentages Function . getStdInPercentages(thisStd::Float64, retType::ReturnType) Transform value of standard deviation into percentage scale if necessary. source # DynAssMgmt.getUnivExtrema Function . getUnivExtrema(thisUniv::Univ) Get minimum and maximum values of mu and sigma for a given universe. Helpful to determine mu / sigma targets for investment strategies. source # DynAssMgmt.getUnivEvolFromMatlabFormat Function . getUnivEvolFromMatlabFormat(muTab::DataFrame, covsTab::DataFrame) Transform Matlab long format of estimated moments into UnivEvol type. source","title":"Functions"}]}